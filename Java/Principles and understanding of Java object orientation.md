# 스프링 입문을 위한 자바 객체 지향의 원리와 이해
- [스프링 입문을 위한 자바 객체 지향의 원리와 이해](https://book.naver.com/bookdb/book_detail.nhn?bid=8920762)를 읽고 정리.
- 앞뒤 구분 없이 책을 읽으며 기억하고 싶은 내용을 쭉 적어 보았다.

## 신기술은 이전 기술의 어깨를 딛고
- 스프링을 비롯한 모든 신기술은 갑자기 하늘에서 뚝 떨어진 것이 아니다. 이전 기술의 어깨를 디딤돌 삼아 그 위에 이전 기술이 제시한 철학과 기법을 정반합의 논리로 정제하고, 이전 기술을 거름 삼아 새로운 철학과 기법을 더해 나타나는 것이다.
- 기계어 -> 어셈블리어 -> C언어(One Source Multi Object Use Anywhere) -> C++ 언어(객체지향 개념의 도입) -> 자바(진정한 객체 지향 언어, Write Once Run Anywhere)
- 위에 나열한 기술들 모두 없던 기술을 새롭게 만든 것이 아니다. 이전 기술의 어깨를 딛고 조금 더 사람들이 편하도록 발전하고 있음을 보여준다.

## 자바와 절차적/구조적 프로그래밍
- JDK : Java Development Kit / 자바 개발 도구 / JVM용 소프트웨어 개발 도구 / javac.exe 포함
- JRE : Java Runtime Environment / 자바 실행 환경 / JVM용 OS / java.exe 포함
- JVM : Java Virtual Machine / 자바 가상 기계 / 가상의 컴퓨터
- 자바 개발 도구인 JDK를 이용해 개발된 프로그램은 JRE에 의해 가상의 컴퓨터인 JVM 상에서 구동된다.
- 프로그램이 메모리를 사용하는 방식
    - 크게 코드 실행 영역과 데이터 저장 영역으로 나뉜다.
    - 객체 지향 프로그램에서는 데이터 저장 영역을 다시 세 개의 영역으로 분할해서 사용한다.
    - 스태틱(static) 영역, 스택(stack) 영역, 힙(heap) 영역

![javamemory](/images/javamemory.png)[그림 출처](http://asfirstalways.tistory.com/329)

- 구조적 프로그래밍은 함수를 써라는 것.
    - 함수를 쓰면 좋은 이유는 중복 코드를 한 곳에 모아서 관리할 수 있고, 논리를 함수 단위로 분리해서 이해하기 쉬운 코드를 작성할 수 있기 때문.
- 그럼 자바 언어에서 이러한 절차적 / 구조적 프로그래밍 유산은 어디에 남아 있을까? `메서드 내부`
- JRE는 먼저 프로그램 안에 main() 메서드가 있는지 확인. main() 메서드의 존재가 확인되면 JRE는 프로그램 실행을 위한 사전 준비에 착수한다.
    - 가상의 기계인 JVM에 전원을 넣어 부팅하는 것이다. 부팅된 JVM은 목적 파일을 받아 그 목적 파일을 실행한다. 
    - JVM이 맨 먼저 하는 일은 `전처리`라고 하는 과정이다. 
        - 모든 자바 프로그램이 반드시 포함하게 되는 패키지가 있다. `java.lang`패키지다.
        - JVM은 가장 먼저 java.lang 패키지를 메모리의 스태틱 영역에 가져다 놓는다.
        - 그 다음 import된 패키지를 메모리의 스태틱 영역에 배치
        - 프로그램 상의 모든 클래스를 메모리의 스태틱 영역에 배치
        - main() 메서드 스택 프레임 배치
        - 변수 공간 배치 등...
- main() 메서드 스택 프레임을 소멸시키는 블록 마침 기호인 닫는 중괄호가 보이면 메모리 소멸, JVM 기동 중지, JRE가 사용했던 시스템 자원을 운영체제에 반납하게 된다.
- 지역변수 : 스택 영역 (스택 프레임이 사라지면 함께 사라짐)
- 클래스 멤버 변수 : 스태틱 영역 (JVM이 종료될 때까지 고정)
- 객체 멤버 변수 : 힙 영역 (가비지 컬렉터가 회수할 때 까지)
- `외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능하다.`
- __멀티 스레드의 메모리 모델은 스택 영역을 스레드 개수만큼 분해서 쓰는 것__
- 객체 지향 프로그래밍은 연산자, 제어문, 메모리 관리 체계 등 구조적 프로그래밍의 많은 부분을 차용하고 있다. 그리고 구조적 프로그래밍은 함수로 그 특징을 대변한다고 볼 수 있는데, 객체 지향 프로그래머들도 메서드 작성에 대한 지혜를 구조적 프로그래밍에서 배워와야 한다. 그러한 뜻에서 객체지향은 절차적 / 구조적 프로그래밍의 어깨를 딛고 만들어 졌다고 할 수 있다.
```
- 스태틱 : 클래스의 놀이터
- 스택 : 메서드의 놀이터
- 힙 : 객체의 놀이터
```

## 자바와 객체 지향
- 함수 : 코드를 논리적인 단위로 구분하고 분할해서 정복하자 - Divide and Conquer(분할 정복)
- 객체지향을 이해하기 위한 큰 그림
    - 세상에 존재하는 모든 것은 사물, 즉 객체(Object)다.
    - 각각의 사물은 고유하다.
    - 사물은 속성을 갖는다.
    - 사물은 행위를 한다.

### 객체 지향의 4대 특성 - 캡! 상추다
- 캡 : 캡슐화(Encapsulation) : 정보 은닉(information hiding)
- 상 : ~~상속(inheritance)~~ : 재사용
- 추 : 추상화(Abstraction) : 모델링
- 다 : 다형성(Polymorphism) : 사용 편의
- 클래스 vs 객체 = 붕어빵틀 vs 붕어빵 ??
    - 금형기계 붕어빵틀 = new 금형기계();
    - 새로운 금형기계를 하나 만들었더니 붕어빵틀이 되었다? X!
- 클래스는 분류에 대한 개념이지 실체가 아니다. 객체는 실체다.
    - 클래스 : 객체 = 펭귄 : 뽀로로 = 사람 : 김연아

### 추상화 : 모델링
- 추상 : 여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용
- 객체지향의 4대 특성은 클래스를 통해 구현됨.
- 객체 : 세상에 존재하는 유일무이한 사물
     - 이러한 객체는 생물이건 무생물이건 속성과 기능을 가지고 있다.
     - 객체 = 클래스의 인스턴스
- 클래스 : 분류, 집합. 같은 속성과 기능을 가진 객체를 총칭하는 개념
- `추상화란 구체적인 것을 분해해서 관심 영역에 대한 특성만을 가지고 재조합하는 것`
- 다시 IT 용어로 바꿔 보면
    - `추상화란 구체적인 것을 분해해서 관심 영역(애플리케이션 경계, Application Boundary)에 있는 특성만 가지고 재조합하는 것 = 모델링`
- 모델은 실제 사물을 정확히 복제하는 게 아니라 목적에 맞게 관심 있는 특성만을 추출해서 표현하는 것이다. 바로 모델은 추상화를 통해 실제 사물을 단순하게 묘사하는 것이다.
- 중요 사항
    - OOP의 추상화는 모델링이다.
    - 클래스 : 객체 = 펭귄 : 뽀로로
    - 클래스 설계에서 추상화가 사용된다.
    - 클래스 설계를 위해서는 애플리케이션 경계부터 정해야 한다.
    - 객체 지향에서 추상화의 결과는 클래스다.
- 추상화의 개념을 넓게 본다면
    - 상속을 통한 추상화, 구체화
    - 인터페이스를 통한 추상화
    - 다형성을 통한 추상화
- 자바는 객체 지향의 추상화를 어떻게 지원하고 있을까? `class` 키워드를 통해 지원하고 있다.
- `추상화 = 모델링 = 자바의 class 키워드`
- 결국 추상화를 통해 모델링을 하게 되면 아래 4가지 요소를 설계하게 되는 것이다.
    - 클래스 멤버 속성(staitc)
        - 예들들어, 쥐(동물) 클래스에서 쥐는 꼬리가 1개라는 속성은 변함없이 가짐.
        - 따라서 static int countOfTail = 1이라고 선언해서 쥐 클래스로 생성되는 여러 객체들에서 따로 선언없이 사용하도록 함.
    - 클래스 멤버 메서드(static)
    - 객체 멈버 속성
    - 객체 멤버 메서드
- static 키워드에 따라 클래스 멤버, 객체 멤버(변수, 메서드)로 구분
    - 클래스 멤버 = static 멤버 = 정적 멤버 : 객체가 아닌 클래스에 속해 있으며, 메모리의 스태틱 영역에 배치되기 때문에 객체의 존재 여부에 관계없이 쓸 수 있다.
    - 객체 멤버 = 인스턴스 멤버
- 스택 영역에 생기는 변수 = 지역변수 : 개발자가 별도로 초기화하지 않으면 쓰레기 값을 갖게 된다.
- 클래스 속성과 객체 속성은 별도의 초기화를 해주지 않아도 정수형은 0, 부동소수점형은 0.0, 논리형은 false, 객체는 null로 초기화된다. (공유 변수를 딱히 누가 초기화해야 한다고 규정할 수 없기 때문)

이름|다른이름|사는 곳(T 메모리)
---|---------|-------------
static 변수 | 클래스 [멤버] 속성, 정적 변수, 정적 속성... | 스태틱 영역
인스턴스 변수 | 객체 [멤버] 속성, 객체 변수... | 힙 영역
local 변수 | 지역 변수 | 스택 영역(스택 프레임 내부)

- 논리적 설계 : 개발 환경 (언어 등)에 영향을 받지 않는 설계
```
쥐
성명, 나이 , 꼬리수
울다()
```
- 물리적 설계 : 개발 환경에 맞춰진 설계
```
Mouse
+name : String, +age : int, +countOfTail : int
+ sing() : voide
```
### 상속: 재사용 + 확장
- 객체 지향에서의 상속은 상위 클래스의 특성을 하위 클래스에서 상속(특성 상속)하고 거기에 더해 필요한 특성을 추가, 즉 `확장`해서 사용할 수 있다는 의미
- 부모 - 자식 표현보다는 상위 - 하위, 슈퍼 - 서브라 표현하자.
- 상속 관계에서 반드시 만족해야 할 문장이 있다.
    - 하위 클래스는 상위 클래스다.
    - 아버지는 할아버지다??, 아들은 아버지다?? - 이상하다. (조직, 계층도)
        - 따라서 부모 - 자식 표현보다는 상위 - 하위, 슈퍼 - 서브라 표현하자는 것.
    - 포유류는 동물이다. 고래는 포유류다 - 자연스럽다.(분류도)
    - 객체 지향 설계 5원칙 가운데 LSP(리스코프 치환 원칙)을 나타내는 말.
- 자바 언어에서는 inheritance라는 키워드는 존재하지 않음. 대신 extends(확장)이 존재.
- is a 관계 보단 `is a kind of` 관계가 명확하다.
- 하위 클래스 is a kind of 상위 클래스
    - 해석: 하위 클래스는 상위 클래스의 한 분류다.
    - 펭귄 is a kind of 조류 -> 펭귄은 조류의 한 분류다.
    - 고래 is a kind of 동물 -> 고래는 동물의 한 분류다.
- 기억할 것
    - 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
    - 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
    - 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.
- 자바는 다중 상속을 지원하지 않는다.
    - 다중 상속의 [다이아몬드 문제](https://namu.wiki/w/%EC%83%81%EC%86%8D(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)) 때문.
    - 대신, 인터페이스를 도입해 다중 상속의 득은 취하고 실은 과감히 버림.

#### 상속과 인터페이스
- 인터페이스 : 구현 클래스 is able to 인터페이스
    - 해석 : 구현 클래스는 인퍼페이스를 할 수 있다.
    - 예 : 고래는 헤엄칠 수 있다.
- 언터페이스는 be able to, 즉 "무엇을 할 수 있는" 이라는 표현형태로 만드는 것이 좋다.
    - Serializable 인터페이스 : 직렬화할 수 있는
    - Comparable 인터페이스 : 비교할 수 있는
- 상위 클래스는 하위 클래스에게 특성 (속성과 메서드)을 상속해 주고, 인터페이스는 클래스가 '무엇을 할 수 있다'라고 하는 기능을 구현하도록 강제하게 된다.
- 상위 클래스는 물려줄 특성이 풍성할수록 좋고(LSP : 리스코프 치환 원칙), 인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋다(ISP : 인터페이스 분할 원칙)
- 논리적으로 이해하기 쉬운 코드 예
    - Penguin pororo = new Penguin();
        - 펭귄 한 마리가 태어나니 펭귄 역할을 하는 pororo라 이름 지었다.
    - pororo.name = "뽀로로";
        - pororo의 name을 "뽀로로"라 하자.
    - pororo.habitat = "남극";
        - pororo의 서식지를 "남극"이라 하자.
    - proro.showName();
        - pororo야 너의 이름을 보여다오.
    - pororo.showHabit();
        - pororo야 너의 서식지를 보여다오.

#### 상속과 메모리
- 메모리의 힙 상에 하위 클래스의 인스턴스가 생성될 때 상위클래스의 인스턴스도 같이 생성된다는 사실을 기억할 것. 

### 다형성 : 사용 편의성
- 객체 지향에서 다형성이라고 하면 오버라이딩(overriding)과 오버로딩(overloading)이라고 할 수 있다.
- 물론 상위 클래스와 하위 클래스 사이에서도 다형성을 이야기할 수 있고, 인터페이스와 그것의 구현 클래스 사이에서도 다형성을 이야기할 수 있지만 가장 기본은 오버라이딩과 오버로딩이다.
- 오버라이딩 : 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의
- 오버로딩 : 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의
- 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩(재정의)한 메서드가 호출된다는 사실을 꼭 기억.
- 오버라이딩을 통한 메서드 재정의, 오버로딩을 통한 메서드 중복 정의를 통해 다형성을 제공하고 이 다형성이 개발자가 프로그램을 작성할 때 사용 편의성을 준다는 것.

### 캡슐화 : 정보 은닉
- 자바의 정보 은닉 (접근 제어자)
    - public : 모두가 접근 가능
    - protected : 상속 / 같은 패키지 내의 클래스에서 접근 가능
    - default : 같은 패키지 내의 클래스에서 접근 가능
    - private : 본인만 접근 가능
- 상속을 받지 않았다면 객체 멈버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 한다.
- 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.(일관된 형식으로 접근하기 위함)
    - 객체참조변수명.정적멤버 형태로도 접근할 수 있지만 권장되지 않음
    - 홍길동.인구수 보단 사람.인구로 접근하는 것이 권장됨.
- 참조 변수의 복사, `기억할 것`
    - 기본 자료형 변수는 값을 값 자체로 판단한다.
    - 참조 자료형 변수는 값을 주소, 즉 포인터로 판단한다.
    - 기본 자료형 변수를 복사할 때, 참조 자료형 변수를 복사할 때 일어나는 일은 같다. 즉, 가지고 있는 값을 그대로 복사해서 넘겨준다.
    - Call By Value와 Call By Reference를 다르다고 이해하기보다는 기본 자료형 변수는 저장하고 있는 값을 그 값 자체로 판단하고, 참조 변수는 저장하고 있는 값을 주소로 판단한다고 이해하기

## 자바가 확장한 객체 지향
- 자바가 객체 지향을 확장하기 위해 사용하는 키워드와 개념

### abstract 키워드 - 추상 메서드와 추상 클래스
- 추상 메서드(Abstract Method)를 간단하게 설명하면 선언부는 있는데 구현부가 없는 메서드
- 추상메서드를 하나라도 갖고 있는 클래스는 반드시 추상 클래스(abstract class)로 선언해야 한다.
    - 물론 추상 메서드 없이도 추상 클래스를 선언할 수 있다.
- 추상클래스는 인스턴스, 즉 객체를 만들 수 없다. 즉, new를 사용할 수 없다.
- 추상메서드는 하위 클래스에게 메서드의 구현을 강제한다. 오버라이딩 강제

### 생성자
- 클래스의 인스턴스, 즉 객체를 만들 때마다 new 키워드를 사용한다.
    - 동물 뽀로로 = new 동물();
- 클래스 명에 붙는 소괄호는 다른 뜻이 있는 걸까?
    - 아니다. 클래스명()도 메서드다.
    - `객체 생성자 메서드`. 줄여서 `생성자`라는 이름으로 부른다.
- 개발자가 아무런 생성자도 만들지 않으면 자바는 인자가 없는 기본 생성자를 자동으로 만들어준다.
- 인자가 있는 생성자를 하나라도 만든다면 자바는 기본 생성자를 만들어 주지 않는다.
- 생성자는 개발자가 필요한 만큼 오버로딩해서 만들 수 있다.

### 클래스 생성 시의 실행블록, static 블록
- 클래스 생성자는 존재하지 않는다. 그러나 클래스가 스태틱 영역에 배치될 때 실행되는 코드 블록이 있다. 바로 `static 블록`이다.
- 클래스의 정보는 해당 클래스가 코드에서 맨 처음 사용될 때 T 메모리의 스태틱 영역에 로딩되며, 이때 단 한번 해당 클래스의 static 블록이 실행된다.
- 여기서 클래스가 제일 처음 사용될 때는 다음 세 가지의 경우 중 하나
    - 클래스의 정적 속성을 사용할 때
    - 클래스의 정적 메드도를 사용할 때
    - 클래스의 인스턴스를 최초로 만들 때

### final 키워드
- final 키워드가 나타날 수 있는 곳은 딱 세군데 (사실 객체 지향 언어의 구성 요소는 딱 세 가지 뿐이다.)
    - 클래스, 변수, 메서드

#### final과 클래스
- 클래스에 final이 붙으면 `상속을 허락하지 않겠다는 의미`

#### final과 변수
- `변경 불가능한 상수`
- 정적 상수는 선언 시에, 또는 정적 생성자에 해당하는 static 블록 내부에서 초기화가 가능하다.
- 객체 상수 역시 선언 시에, 또는 객체 생성자 또는 인스턴스 블록에서 초기화 할 수 있다.
- 지역 상수 역시 선언 시에, 또는 최초 한 번만 초기화가 가능하다.
- 셋 모두 한 번 초기화되면 값을 변경할 수 없다.

#### final과 메소드
- 재정의, 즉 오버라딩을 금지

### instanceof 연산자
- 인스턴스는 클래스를 통해 만들어진 객체
- instanceof 연산자는 만들어진 객체가 특정 클래스의 인스턴스인지 물어보는 연산자.
- 결과로 true 또는 false를 반납.
- `객체_참조_변수 instanceof 클래스명`
- 객체 참조 변수의 타입이 아닌 실제 객체의 타입에 의해 처리됨.
- 상속 관계 뿐만 아니라 인터페이스의 구현 관계에서도 동일하게 적용됨.
- 객체 지향 설계 5원칙 가운데 LSP(리스코프 치환 원칙)을 어기는 코드에서 주로 나타나는 연산자이기에 냄사가 나는 코드가 아닌지, 즉 리팩토링 대상이 아닌지 점검 필요.

### package 키워드
- 네임스페이스(이름공간)를 만들어주는 역할
- 서로 다른 팀에서 같은 클래스를 작성하더라도. 이름 공간을 두어 충돌을 피할 수 있다.
    - 고객사업부.Customer, 마케팅사업부.Customer (전체 이름 지정을 통한 충돌을 피할 수 있음)

### interface 키워드와 implements 키워드
- 인터페이스는 public 추상 메서드와 pulic 정적 상수만 가질 수 있다.
    - 메서드에 public과 abstrace, 속성에 public과 static, final을 붙이지 않아도 자동으로 자바가 알아서 붙여준다.
    - 아래는 명확한 코드
```java
interface Speakable{
    public static final double PI = 3.14159;
    public static final double absolureZeroPoint = -275.15;

    public abstract void sayYes();
}
```
- 인터페이스에 정적 상수, 객체 추상메서드만 가질 수 있었던 것에 반해 자바8이 출시되면서 디폴트 메서드라고 하는 객체 구상 메서드와 정적 추상 메서드를 지원할 수 있게 언어 스펙이 바뀌었다.

### this 키워드
- 객체가 자기 자신을 지칭할 때 쓰는 키워드
- 지역 변수와 속성(객체 변수, 정적 변수)의 이름이 같은 경우 지역 변수가 우선한다.
- 객체 변수와 이름이 같은 지역 변수가 있는 경우 객체 변수를 사용하려면 `this`를 접두사로 사용
- 정적 변수와 이름이 같은 지역 변수가 있는 경우 정적 변수를 사용하려면 `클래스명`을 접두사로 사용

### super 키워드
- 바로 위 상위 클래스의 인스턴스를 지칭


## 객체 지향 설계 5원칙 - SOLID
- 객체 지향의 특성을 올바르게 사용하는 방법, 즉 객체 지향 언어를 이용해 객체 지향 프로그램을 올바르게 설계해 나가는 방법이나 원칙이 존재할까?
- 객체 지향 설계(OOD; Object Oriented Design)의 정수라고 할 수 있는 5원칙이 집대성됐는데, 바로 SOLID다.
    - SRP(Single Responsibility Principle) :단일 책임 원칙
    - OCP(Open Closed Principle) : 개방 폐쇄 원칙
    - LSP(Liskov Subsitution Principle) : 리스코프 치환 원칙
    - ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
    - DIP(Dependency Inversion Principle) : 의존 역전 원칙
- 하늘에서 뚝 떨어진 원칙이라기 보다는 응집도는 높이고 (High Cohension), 결합도는 낮추라(Loose Coupling)는 고전 원칙을 객체 지향의 관점에서 재정립한 것이라고 할 수 있다.
```
결합도와 응집도
- 결합도는 모듈(클래스) 간의 상호 의존 정도로서 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다
- 응집도는 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이하다.
<http://toby.epril.com/?p=727> 참고
```
- SOLID는 객체 지향 프로그램을 구성하는 속성, 메서드, 클래스, 객체, 패키지, 모듈, 라이브러리, 프레임워크, 아키텍처 등 다양한 곳에 다양하게 적용
- SOLID가 개념이긴 하지만 우리가 만드는 제품, 즉 소프트웨어에 녹여 내야 하는 개념이다.
- SOLID는 객체 지향 4대 특성을 발판으로 하고 디자인 패턴의 뼈대이며 스프링 프레임워크의 근간이기도 하다.

### SRP - 단일 책임 원칙
- `어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다  - 로버트 C.마틴`
- 클래스를 예로 들면 하나의 클래스는 각각 하나의 역할과 책임만 갖게 해야한다.(클래스를 역할과 책임에 따라 분리해서)
- 메서드가 단일 책임 원칙을 지키지 않을 경우 나타나는 대표적인 냄새가 바로 분기 처리를 위한 if문 이다.
- 단일 책임 원칙과 가장 관계가 깊은 것은 바로 모델링 과정을 담당하는 `추상화`
    - 애플리케이션의 경계를 정하고 추상화를 통해 클래스들을 선별하고 속성과 메서드를 설계할 때 반드시 단일 책임 원칙을 고려하는 습관을 들이자.
    - 또한 리팩토링을 통해 코드를 개선할 때도 단일 책임 원칙을 적용할 곳이 있는지 꼼곰히 살피자.

### OCP - 개방 폐쇄 원칙
- `소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다. - 로버트 C.마틴`
    - 의역 : `자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.`
- 예. JDBC
    - JDBC를 사용하는 클라이언트는 데이터베이스가 오라클에서 MySQL로 바뀌더라도 Connection을 설정하는 부분 외에는 따로 설정할 필요가 없다. Connection 설정 부분을 별도의 설정 파일로 분리해두면 클라이언트 코드는 단 한줄도 변경할 필요가 없다.
    - 오라클을 MySQL이나 MS-SQL로 교체할 때 자바 애플리케이션은 JDBC 인터페이스라고 하는 완충 장치로 인해 변화에 영향을 받지 않는다.
    - 바로 `자바 애플리케이션은 데이터베이스라고 하는 주변의 변화에 닫혀 있는 것`이다.
    - 데이터베이스를 교체한다는 것은 `데이터베이스가 자신의 확장에는 열려 있다는 것`이다.
- 개방 폐쇄 원칙을 무시하고 프로그램을 작성하면 객체 지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 얻을 수 없다.
- 따라서 반드시 지켜야 할 원칙.
- 스프링 프레임워크 - 개방 폐쇄 원칙을 교과서적으로 활용하고 있음을 확인 가능.

### LSP - 리스코프 치환 원칙
- `서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다 - 로버트 C.마틴`
- 상속에 대해 설명하면서 객체 지향에서의 상속은 조직도나 계층도가 아닌 분류도가 돼야 한다고 했다.
    - 하위 클래스 is kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다.
- 위의 문장대로 구현된 프로그램이라면 이미 리스코프 치환 원칙을 잘 지키고 있다고 할 수 있다.
- 하지만 위 문장대로 구현되지 않은 코드가 존재할 수 있는데 바로 상속이 조직도나 계층도 형태로 구축된 경우다.
- 아버지를 상위 클래스 (기반 타입)로 하는 딸이라는 하위 클래스 (서브 타입)가 있다.
    - 아버지 춘향이 = new 딸() - 리스코프 치환 원칙 위배
    - 이상하다! 딸에게 아빠의 역할을 맡기고 있다. 아버지 객체가 가진 행위(메서드)를 할 수 있어야하는데 춘향이에게 어떤 역할을 시킬 수 있을까?
- 동물 뽀로로 = new 펭귄() - 분류도 형태, 논리적인 흠이 없다. 리스코프 치환원칙 만족
- `하위 클래스 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.`
- 결국 리스코프 치환 원칙은 객체 지향의 상속이라는 특성을 올바르게 활용하면 자연스럽게 얻게 되는 것이다.

### ISP - 인터페이스 분리 원칙
- `클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다 - 로버트 C.마틴`
- 결론적으로 단일 책임 원칙(SRP)과 인터페이스 분할 원칙(ISP)은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다.
- 프로젝트 요구사항과 설계자의 취향에 따라 단일 책임 원칙이나 인터페이스 분할 원칙 중 하나를 선택해서 설계할 수 있다.
- 하지만 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이라고 할 수 있다.
- 인터페이스 분할 원칙을 이야기할 때 항상 함께 등장하는 원칙 중 하나로 인터페이스 최소주의 원칙이라는 것이 있다. 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공하라는 것.

### DIP - 의존 역전 원칙
- `고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.`
- `추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다`
- `자주 변경되는 구체(COncrete) 클래스에 의존하지 마라 - 로버트 C.마틴`
- 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이 의존 역적 원칙.
- 의존 역전 원칙을 의역하면
    - `자신보다 변하기 쉬운 것에 의존하지 마라.`
- 상위 클래일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래스를 통해 의존하라는 것이 바로 의존 역전 원칙이다.
- 의존 역전 원칙을 적용한 대표적인 사례는 이전에 OCP에서 설명했던 JDBC에서 확인할 수 있다.

### 정리 - 객체 지향 세계와 SOLID
- SOLID는 객체 지향을 올바르게 프로그램에 녹여내기 위한 원칙이다.
- SOLID를 이야기할 때 빼놓을 수 없는 것이 SoC이다.
- SoC (Separation of Concerns) 관심사의 분리.
    - 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모으고, 관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리하라는 것이다.
    - 하나의 속성, 하나의 메서드, 하나의 클래스, 하나의 모듈, 또는 하나의 패키지에는 하나의 관심사만 들어 있어야 한다는 것
    - SoC를 적용하면 자연스럽게 SRP, ISP, OCP에 도달하게 된다.
- SOLID 원칙을 적용하면 소스 파일의 개수는 더 많아지는 경향이 있다. 하지만 이렇게 많아진 파일이 논리를 더욱 잘 분할하고, 잘 표현하기에 이해하기 쉽고, 개발하기 쉬우며, 유지와 관리, 보수하기 쉬운 소스가 만들어진다.
- 스프링 프레임 워크를 이해하기 위해서는 객체지향의 특성과 설계 원칙, 그리고 디자인 패턴에 대해 이해하여야 한다.