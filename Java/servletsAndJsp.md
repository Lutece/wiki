# Servlet & JSP 기초 정리
- Head First Servlet & JSP를 읽고 기억해놓고 싶은 것을 정리.

### 컨테이너가 주는 혜택
- 컨테이너는 서블릿을 실행하고 관리한다.
- 통신(커뮤니케이션) 지원
- 생명주기(라이프사이클) 관리
- 멀티스레딩 지원
- 선언적인 보안 관리
- JSP 지원 등

### 컨테이너는 요청을 어떻게 다룰까?
1. 사용자가 서블릿에 대한 링크를 클릭한다
2. 컨테이너는 들어온 요청이 서블릿이라는 것을 간파하곤 다음 두 객체를 생성한다
  (1) HttpServletResponse
  (2) HttpServletRequest
3. 컨테이너는 사용자가 날린 URL을 분석하여 어떤 서블릿에 대한 요청인지 알아낸다(DD 참조) 그 다음 해당 서블릿 스레드를 생성하여 Request, Response 객체를 인자로 넘긴다.
4. 컨테이너는 서블릿 service() 메소드를 호출한다. 요청에 지정한 방식(Method)에 따라 doGet()을 호출할지, doPost()를 호출할지 결정한다.
5. doGet() 호출을 가정하고 doGet() 메소드는 동적인 페이지를 생성한 다음, 이를 Response 객체에 실어 컨테이너로 보낸다. 보내고 난 후에도 컨테이너는 Response 객체에 대한 참조(레퍼런스)를 가지고 있다는 것을 잊지 말자.
6. 스레드 작업이 끝나면, 컨테이너는 Response 객체를 HTTP Response로 전환하여 클라이언트로 내려 보낸다. 이제 마지막으로 Request와 Response 객체를 소멸시킨다.(가비지 컬렉션)

### 서블릿의 생명주기
- 컨테이너는 서블릿을 로딩한다. 그 다음 디폴트 생성자를 호출하고, init() 메소드를 실행한다.
- init() 메소드는 서블릿 일생 중 단 한번만 호출된다. ( 클라이언트에게 서비스를 제공하기 전에 실행)
- init() 메소드에서 ServletConfig(서블릿 당 하나) 객체와 ServletContext (웹 애플리케이션 당 하나) 객체에 접근할 수 있다. 이 두 객체를 통해 서블릿 밑 웹 어플리케이션 설정 정보를 파악할 수 있음.
- 컨테이너는 서블릿의 destroy() 메소드를 호출하여 서블릿 일생을 마감
- 서블릿은 일생의 대부분을 클라이언트 요청에 대한 응답으로 service() 메소드를 실행하는데 보낸다.
- 서블릿에 대한 클라이언트 요청은 별개의 스레드에서 실행된다. 서블릿 인스턴스는 하나 밖에 없음.

### 정리해보면..
- 컨테이너는 서블릿 디폴트 생성자를 실행 (생성된 서블릿 인스턴스는 새로 생성없이 계속 사용), init() 실행 (최초에 한번 실행)
- 클라이언트 요청
- 컨테이너는 서블릿 스레드 생성 (요청당 하나의 스레드 생성)
- DD 분석해서 어느 서블릿 요청인지 확인
- 해당 서블릿의 service() 실행 -> doGet()/doPOst() 실행, 이때 request, response 인자로 넘김
- 로직 수행
- 응답 후 스레드 소멸
- destroy() - 서버 다운 전 한번

### 리다이렉트와 디스패치
- 리다이렉트(Redirect) : 요청에 대한 응답을 누가할 지 선택, 요청을 완전히 다른 URL로 방향을 바꿈, 브라우저는 서버에서 정한 URL을 받아 새로운 요청을 보냄. 클라이언트에서 동작
- 디스패치(dispatch) : 웹 애플리케이션에 있는 다른 컴포넌트에게 처리를 위임 (서블릿 -> jsp) 서버에서 동작

### 세 가지 생존범위 : Context, Request, Session
- Context : 전체 애플리케이션에서 공유. 스레드-안전(x)
- Session : 하나의 Request에만 관련된 것이 아니라 클라이언트 세션에 관련. 스레드-안전(x)
- Request : 특정 요청에만 관련된 데이터 등. 스레드-안전(o)

### links
- [Head First Servlet & JSP](http://book.naver.com/bookdb/book_detail.nhn?bid=5902081)
