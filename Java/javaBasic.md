# 자바 기초 정리

- 자바 기초를 다시 한 번 (가볍게)다지기 위해 [인프런 - 초보부터 개발자 취업까지!! 실전 자바 강좌](https://www.inflearn.com/course/%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B0%95%EC%A2%8C/)를 듣기 시작했다.
- 인간은 망각의 동물인 걸 인지하고 있으므로 읽고 상기시킬 수 있을 정도의 깊이로 정리해볼 것이다.
- 이 강의의 특성상 쉽게 설명하기 위해 비유를 들어 많이 설명하는데 딱히 필터링 없이 들은 대로 정리할 예정이다.
- 100km/h의 속도로 공부하지 말고, 1km/h의 속도로 공부하되, 꾸준히 공부하자.

### 1. Java 언어의 탄생
- 1990년대 초 JAVA의 탄생
- 제임스 고슬링(James Gosling)이 가전제품의 효율적 사용을 위한 프로그램 언어로 JAVA를 개발
- 기존의 C/C++에 비해 속도가 느려 외면을 받음
- 1990년대 말에서 2000년대에 들어오면서 인터넷의 등장으로 관심을 얻기 시작

### 2. Java의 플랫폼
- JAVA SE(Stand Edition) : JAVA Application 개발  >  일반적인 어플리케이션 개발
- JAVA ME(Mobile Edition) : 휴대 가능한 소형 디바이스에 사용을 목적으로 개발  > 현재의 스마트폰 등작으로 쇠퇴
- JAVA EE(Enterprise Edition) : 기업 솔루션 개발  > 가장 핵심

### 3. Java 언어의 특징
- Java Virtual Machine
- Garbage Collection
- Object Oriented Program(OOP)
- JVM < API < JRE < JDK

### 4. 변수
- 변수란? 모든 것을 담을 수 있는 요술주머니.

### 5. 자료형
- 기본 자료형(primitive) : Java언어에 이미 존재하고 있는 데이터 타입. 주로 간단한 데이터들 이다. (예. Int, double, Boolean, char 등등…)
- 객체 자료형(object) : 여러가지 데이타들이 모여 있는 복잡한 데이터로 기본 자료형에 비해 크기가 크다. (예. String, System, ArrayList 등등…)

### 6. 형변환
- 묵시적 형변환 : 작은 요술주머니의 데이터를 큰 요술주머니로 옮기는 것
- 명시적 형변환 : 큰 주머니의 데이터를 작은 주머니로 옮기는 것. 데이터 손실이 있을 수 있으며, 코드에 명시해 주여야 한다.

### 7. 연산자
- 연산자란 ? 일정한 규칙을 가지고 계산하는 것으로서, 우리가 일상생활에서 사용하고 있는 덧셈, 뺄셈, 곱셈, 나눗셈을 비롯하여 프로그램에서는 자동 증감, 동등 비교, 비트 연산 등 많은 연산자가 있다
- 산술 연산자, 자동증감 연산자, 동등비교 & 관계 연산자, 논리 연산자, 삼항 연산자, 할당 연산자, 줄여쓰는 연산자 등


### 8. 제어문
- 어떤 상황을 판단하여 결과를 true 또는 false를 반환함.
- if : 만일 ~ 한다면…. 으로 조건을 만족하는 경우에 해당 프로그램이 수행
- if ~ else
- if ~ else if : 다양한 조건 중 한가지를 선택
- switch

### 9. 반복문(루프문)
- for : 미리 설정한 횟수 만큼 반복적으로 수행 (break, continue도 숙지)
- while : 하나의 조건으로 for문에 비하여 간결


### 10. 배열
- 배열이란? 하나의 데이터만 가지고 있던 변수(요술주머니)와 달리 여러 개의 데이터를 가지고 있는 요술주머니.   
즉, 여러 개의 변수(요술주머니)를 모아놓은 또 하나의 요술주머니하고 생각하면 쉽다.
- 배열의 크기는 최초에 한번 설정되면 변경이 불가 하다.
- 변수 선언 : int i = 10;
- 배열 선언 : int[] iArr = {10, 20, 30, 40, 50};, int[] iArr = new int[5];
- 배열에는 기초자료형 변수와 달리 데이터가 들어 있지 않다.
- 즉, 배열은 배열을 구성하고 있는 데이터들의 주소값(레퍼런스)를 가지고 있다


### 11. 객체
- 객체는 같은 종류의 데이터와 로직이 함께 있는 구성체
- 객체는 클래스로부터 생성
- 생성된 객체는 동일한 클래스에서 생성되었다 하더라고 완전한 독립체이다. 따라서 객체 안에 종속되어 있는 데이터는 완전히 별개의 데이터
- 객체변수에는 메모리 주소값이 들어감.
- 객체지향 프로그램의 기초적인 코딩 방법 : 클래스, 인스턴스 변수(멤버변수), 메소드, 생성자, this

### 12. 핵심은 데이터의 효율적인 관리
- 프로그래밍이란 작업은 데이터를 누군가가 효율적으로 활용할 수 있게 시스템을 만드는 행동.
- 버그없이 돌아는 가는데, 데이터를 다루는 기술이 부족하여 시스템 속도가 너무 느리다면, 효율적인 시스템이라고 할 수 없을 것.
- 우리 개발자들은 코딩 보다 프로그래밍 구조에 대해서 더욱 깊이 생각해야 된다.
- 시간을 내어 리팩토링 관련 서적을 보는 것도 많은 도움이 될 것.

### 13. 패키지
- JAVA에도 많은 .java파일들이 존재 한다. 이러한 많은 파일을 효율적으로 관리하기 위해 JAVA에서는 ‘패키지’라는 구조를 사용 한다.
- 패키지 = 클래스를 모아 놓은 폴더
- 주로 패키지 이름은 유니크한 도메인 주소를 역방향으로 하여 만듦
- 패키지를 만들고 클래스를 만든 후 서로 다른 패키지의 클래스를 사용하려고 할때는 반드시 import 키워드를 사용해서 해당 클래스를 임포트

### 14. 접근 제한
- 접근 제한이란, 말 그대로 클래스의 데이터(인스턴스) 또는 메소드에 대해서 다른 클래스로부터의 접근을 제한하는 것
- public : 접근 제한을 하지 않는다. 즉 다른 모든 클래스에서 사용 가능.
- private : 자신의 클래스에서만 사용 가능. 외부에서는 사용할 수 없다.
- protected : 해당 클래스와 동일한 패키지에 있거나 상속받은 클래스일 경우에만 사용 가능.
- default : 해당 클래스와 동일한 패키지에서만 사용 가능.

### 15. static
- 공유, 객체를 생성하는 것이 아닌 클래스에 있는 데이터를 공유.
- 메모리의 힙 영역이 아닌 데이터 영역에 존재
- static은 클래스 변수(static 키워드를 사용한 변수)
- 객체는 클래스에서 생성(복사)되어 진다.
- 클래스 하나에서 무한대로 객체를 생성할 수 있고 그러한 객체는 모양은 동일할지 모르지만, 전혀 다른 덩어리이다.
- 하지만 static이 붙은 변수는 객체 변수가 아닌 클래스 변수로써 객체가 생성되기 전에 이미 존재.
- static 변수 : 객체생성 없이 class. 으로 접근 가능.
- 객체 생성을 하지 않고도 사용할 수 있다는 것은 분명 장점이지만, 한편으로 생각해 보면 가비지콜렉터의 관리 밖에 있기 때문에 항상 메모리에 상주해 있다. (따라서 static 사용에 신중해야함.)
- static 변수로 사용되는 대표적인 예는 아마도 빈번히 사용되는 상수(변하지 않는 수)

### 16. 상속
- 어떤 객체가 다른 객체로부터 객체의 데이터(속성)와 메소드를 상속 받을 수 있다.
- 이럴 경우 상속받은 객체는 상속해준 객체의 데이터 및 메소드를 이용할 수 있고 또는 변경(재정의, override)할 수 있다.
- extends 키워드 사용.
- 다중 상속 불가능.
- 상속이 필요한 이유
  - 첫째, 훌륭한 선배들이 만들어 놓은 프로그램이 있다면 상속을 통해서 훌륭한 결과물을 빠른 시간내에 만들 수 있다.
  - 둘째, 다양한 객체(타입)를 상속을 통해서 하나의 객체(타입)으로 묶을 수 있다. 즉, 다양한 객체를 하나로 통일 시킬 수 있다.
- 오버라이드(override) - 부모 클래스의 메소드를 자식 클래스에서 재정의 함.
- override의 장점은 클래스를 상속받아 일부 메소드를 수정(재정의)할 수 있다는 것.
- 하지만, 자식클래스에서 부모클래스를 override하면 부모클래스의 메소드는 사용할 수가 없다. 이것이 override의 단점
- 자식 클래스에서 부모클래스의 메소드를 사용하고자 할 때 super 키워드를 사용
- 상속을 받은 자식클래스를 생성하면 부모클래스의 생성자가 호출이 먼저 된다.

### 17. 추상클래스
- 추상적으로 정의할 테니, 사용자가 꼭 재정의(overriding) 하라. (강제성)
- 선언부는 있지만, 구현부는 없음.
- abstract 키워드 사용
```java
public abstract Class className{
    public abstract void method1();
    public abstract void method2();
  }
```
- 부모 클래스의 메소드를 자식 클래스에서 변경할 일이 없다면, 일반 클래스를 이용한 상속이 좋다.
- 자식클래스에서 꼭 재정의 해야 하는 부분이 있다면, 추상클래스를 이용하여 강제로 재정의 하게 해야 된다.

### 18. 인터페이스
- (1) 인터페이스란? 객체와 객체의 소통 수단.
- (2) 작업명세서 - 앞으로 이렇게 만들자.
- (3) 다형성 - java에서 다형성을 가능하게 함.
- (4) 객체를 부속품화 - 다양한 객체를 제품의 부속품처럼 개발자의 마음대로 변경할 수 있다. (다형성)
- 인터페이스 문법
  - 실제 기능은 없다. 구현된 기능이 없다. 추상메소드와 상수만이 존재.
  - private 불가, 상수를 만들때 private 접근 제한자 안됨
  - 추상화 - 메소드는 무조건 추상 메소드만 존재
  - 객체타입 - 인터페이스는 객체는 아니다. 다만, 객체 타입으로만 사용 된다
  - 구현은 실행되는 객체의 메소드에서 한다.
```java
public interface interfaceFx{
  public static int CONSTANT_NUM = 1000;
  public void calculate();
}
```
- 사용은 클래스에서 implements 키워드 사용하여.
- 다중 구현 가능. (=다형성이 존재)
- 꼭 추상메소드 재정의

### 19. 인터페이스와 추상클래스
- 공통점
  - 추상메소드를 가지고 있다. - 추상메소드를 가지고 있어 하위 클래스에서 구현해야 한다.
  - 데이터 타입이 목적이다. - 객체생성이 목적이 아닌 데이터 타입을 정의하는 것이 목적
  - 객체 생성은 'anonymous'를 이용해야 한다. (부모클래스에서 해당 메소드를 구현해놓지 않으면 익명클래스를 통한 구현)
- 차이점
  - 상속, 구현을 통한 사용의 차이
  - 구성요소 차이 - 추상클래스 => 변수, 메소드, 인터페이스 => 상수, 추상메소드
  - 단일상속, 다중구현

### 20. 디자인 패턴
- 개발자 선배들이 객체지향 언어의 장점들을 모아 가장 효율적으로 개발할 수 있게 만들어 놓은 틀.
- 상속, 추상화 등이 왜 필요한지 알게됨.
- 싱글톤 패턴(Singleton Pattern)
  - 어떤 클래스의 인스턴스는 오직 하나임을 보장하며, 이 인스턴스에 접근할 수 있는 전역적인 접촉점을 제공하는 패턴
- 스트레티지 패턴(Strategy Pattern)
  - 알고리즘 군을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있도록 만든다.
  - 스트레티지를 활용하면 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.
  - 쉽게말하면, 어떤 객체를 만들 때 객체가 가지는 기능들이 다양하게 존재한다. 이러한 기능들을 추상화 하여 언제든지 적용할 수 있게 만드는 것. 즉 기능을 부품화 하는 것이다.

### 21. String API
- String : 객체 자료형, 하지만 뒤에 생성자(new)를 사용하지 않고 기초데이터를 만들 때 처럼 초기화 한다.
  - ex) String string = "HelloWorld";
- String의 주요 기능들(메소드)
  - concat : 문자열 연결
  - substring : 문자열 자르기
  - length : 문자열 길이
  - toUpperCase : 대문자로 만들기
  - toLowerCase : 소문자로 만들기
  - charAt : 특정위치의 글자 찾기
  - indexOf : 특정문자열의 위치
  - equals : 문자열 비교
  - trim : 문자열 공백제거
  - replace : 특정문자 변경
  - replaceAll : 특정문자열 변경
- String 단점 : 메모리를 과소비 한다. String 객체의 경우 처음 초기화된 데이터에 변화가 생기면 기존 것을 재활용 하기 보다는 새것을 찾는다.
- 따라서, String 클래스의 대안으로 StringBuffer, StringBuilder 등장 (속도적인 측면에서 더욱 개선됨)
- StringBuilder 주요 기능(메소드)
  - StringBuilder는 new를 이용한 생성 : StringBuilder stringBuilder = new StringBuilder("abcdefg");
  - append : 문자열 추가
  - insert : 특정 위치에 문자열 추가
  - delete : 문자열 삭제
  - deleteCharAt : 특정 문자 하나 삭제
- StringBuffer와 StringBuilder와 비슷하나 StringBuilder가 속도 면에서 좀 더 빠르다.

### 22. 날짜(Calendar) API
- Calendar calendar = Calendar.getInstance();
  - int year = calendar.get(Calendar.YEAR);
- System.currentTimeMillis() - 현재 시간읠 1/1,000초 단위로 표시 (속도 테스트 용도로 많이 사용)

### 23. Random 클래스
- 예전에는 Math.random()을 많이 이용하였으나, 요즘은 Random 클래스를 많이 사용한다.
- dobule d = Math.random();
  - static
- Random random = new Random();
  - random.nextInt(100);

### 24. Scanner 및 Sysout
- Scanner : 키보드에서 타이핑 하는 문자열 또는 입출력 프로그래밍에서 문자열을 읽어올 때 사용
  - Scanner scanner = new Scanner(System.in);
  - scanner.nextLine() : 처음 개행 문자를 만나면 거기 까지만 읽고 나머지는 버림 (데이터 손실 주의)
- System.out.println (sysout)

### 25. Wrapper 클래스의 이해
- Wrapper 클래스는 기초데이터를 객체데이터로 변환 시키는 클래스
  - Integer integer = new Integer(10);
  - 기초데이터에 상응하는 객체데이터가 있음

### 26. Timer 클래스
- Timer객체는 일정한 시간이 되면, TimerTask 객체가 작동된다.
- 단, TimerTask클래스는 추상클래스이다. 따라서 TimerTask 클래스를 상속받는 클래스를 만들어서 사용 해야 한다.

### 27. StringTokenizer 클래스
- 문자열을 분할 할 때 사용하는 대표적은 클래스
- String str = "2018/12/25";
- StringTokenizer tokenizer = new StringTokenizer(str, "/");

### 28. 예외처리
- 예외처리란? 프로그램에서 문제가 발생될 만한 곳을 예상하여 사전에 문제가 발생하면 이렇게 해라라고 프로그래밍하는 것.
- 예외의 필요성은 어느 한 부분에서 예외가 발생하더라도 계속해서 프로그램이 동작되도록 하는데 목적이 있다.
- 예외처리 문법 (try ~ catch)
```java
  try{
    문제가 발생할 수 있는 로직
  }catch(Exception e){
    try{}안에서 문제가 발생했을 때 대처방안 기술
  }
```
- finally
  - try와 catch문의 영향 없이 무조건 실행
- 예외처리 문법 (throws)
  - 예외를 발생시킨(호출)쪽으로 예외를 던져버리는 방식
- Exception 클래스는 많은 예외들(자식클래스)를 가지고 있다.
  - ArrayIndexOutOfBoundsException : 배열 사용시 존재하지 않는 index 값을 호출하면 발생
  - NullPointerException : 존재하지 않는 객체를 가리킬 때 발생
  - NumberFormatException : 문자를 숫자로 처리할때 발생(숫자로 변경할 수 없는 문자열을 변경하려고 함.)

### 29. Collections (자료구조)
- 컬렉션이란? = 자료구조
- JAVA도 결국 효과적인 데이터를 처리하기 위한 수단
- 다양항 자료구조형이 제공되는 이유는 데이터의 성질에 따라서 데이터를 관리(정리)해야 하는 방식이 다르기 때문
- 자료구조형안에는 객체의 레퍼런스만을 관리한다.
- List
  - ArrayList : 배열과 유사, 인덱스 존재 (중요), 데이터 중복 가능
  - LinkedList : ArrayList와 유사.
  - Vector : ArrayList와 비슷하지만 속도가 떨어 진다. 하지만 ArrayList보다 멀티스레드 환경에서 안전.
- Map : 키와 값, 인덱스 없음, 키는 유니크 해야한다.
  - HashMap
- Set : 데이터의 순서 x, 중복된 데이터 허락x
  - HashSet
- Iterator (interface) : 반복자, 데이터를 반복적으로 검색하는데 유용한 인터페이스. 참고로 모든 자료구조형은 iterator() 메소드 지원.
