# Linux 명령어 정리

## sudo 임시로 관리자 권한 얻기
- sudo : 관리자 권한 행사
- sudo -i, sudo su : root로 로그인

## grep 다양한 문자열을 한 번에 검색
- 파일의 내용을 빠짐없이 확인해서 찾는 문자열이 포함되어있는지 조사
- global regular expression print - 파일 전체에서 정규표현식과 일치하는 위치를 출력하라
```
$ grep -r "검색하고 싶은 문자열" /home/docs
```
- -r : 서브 폴더까지 검색하도록 지정
- 정규 표현식(regular expression)
```
- () : 그룹화
- | : 좌우 중 하나
- ? : 직전 표현이 0회 또는 1회 등장
- * : 직전 표현이 0회 이상 연속해서 등장
- + : 직전 표현이 1회 이상 연속해서 등장
- . : 임의이 한 문자
- ^ : 줄 머리
- $ : 줄 끝
```
- -E : 정규표현식 사용
- -i : ignore case, 알파벳 대소문자 차이 무시하고 검색
```
$ grep -r -i "yameno tarou" 디렉토리경로
$ grep -r -i -E "((야메노) *(타로) | yameno +tarou)" 디렉토리 경로
```

## vim
- 편집 : 시작 -> 노멀모드 -> i 입력 -> 끼워넣기 모드로 편집 -> esc -> :wq (저장 & 종료)
- 검색 : 노멀모드 -> / 입력
  - N : 검색된 곳을 순서대로
  - Shift N : 반대 방향
  - 정규표현식으로 검색 : / 뒤에 \v(백슬래쉬, 소문자v)
  - EX) /\v(CP949|EUC-KR)
- 복사 : 노멀모드 -> v - 선택모드 (화살표를 이용한 범위 지정)
- 양크 : (yank:끌어당기다) - 클립보드에 텍스트가 복사됨
- 붙여넣기 : Shift + p
  - 10회 반복해서 붙여넣기 : 1, 0, Shift, p
- 되돌리기 : u (undo)
- 되살리기 : ctrl + r (redo)
- ctrl + z : 실행중인 애플리케이션 일시 정지
  - fg : 다시 실행 (foreground)

## tmux 가상 단말
- $ sudo apt-get install tmux
- 실행 : $ tmux
- 네트웍이 끊긴경우 ssh 재접속해서 $ tmux attach 입력
- ctrl + b (tmux의 기능 사용) 입력한 다음
  - d 입력 : tmux 화면에서 빠져나옴 (detach)
  - c 입력 : create : 새로운 탭 열기
  - p 입력 : previous : 이전 탭
  - n 입력 : next : 다음 탭
  - " 입력 : 화면 가로로 분할
  - % 입력 : 화면 세로로 분할
    - ctrl + b + 방향키 : 분할된 화면 포커스 전환
    - exit : 분할 해제
    - 분할키를 입력하면 그때 포커스가 있는 화면을 분할함.
  - ctrl 누르면서 방향키 : 분할 경계선 (화면 비율) 변경

## 명령어 이력
- 방향키 위, 아래(↕)를 이용한 이전에 실행한 명령어 이력 표시
- $ vi ~/.bash_history
- 명령어 검색 기능
  - 후방 검색(현재 위치보다 오래된 방향으로 이동) : ctrl + R
  - ctrl + R을 사용하면 검색 위치가 오래된 방향으로 이동되서 그보다 새로운 명령어 이력은 검색할 수 없게 된다.
    - 따라서, 아래와 같이 역방향(전방검색)이 가능하도록 수정
    - 1. vi ~/.bash_history
    - 2. shift + G 로 마지막으로 이동해서 stty stop undef 입력
    - 3. :wq
    - 4. 재로그인 (bash 재실행, 새로운 설정 읽어 들임)
  - 전방 검색(현재 위치보다 새로운 방향으로 이동) : ctrl + S
- 이력 저장 건수 설정
  - 1. $ vi ~/.bashrc
  - 2. shift + G 로 마지막으로 이동
  - 3. export HISTSIZE=10000
  - 4. export HISTFILESIZE=10000
  - 5. c, d는 같은 값으로 지정하고 :wq 저장.
  - 6. 재로그인
- 가상 단말 여러개의 bash는 각자의 명령어 이력 복사본을 가짐
  - 따라서, 다른 화면에서 실행한 명령어는 또 다른 화면에서 실행한 명령어를 검색할 수 없다.
  - $ vi ~/.bashrc에 아래를 추가
  ```
  function share_history{
    history -a
    history -c
    history -r
  }
  PROMPT_COMMAND='share_history'
  shopt -u histappend
  ```
  - bash_history와 메모리 복사본을 자주 동기화 하라는 의미

## scp (Secure copy)
- 간단한 사용법
  - mint : 로그인 할 사용자
  - 192.~~ : 접속할 컴퓨터 (네트워크명 또는 ip)
  - 복사할 곳: /tmp/
```bash
$ scp ./file.ext mint@192.168.1.10:/tmp/
```
- 자신의 pc 경로로 복사하는 것도 가능
```bash
$ scp mint@192.168.1.10:/tmp/file.txt ~/
```
- 와일드카드, -r(recursively) 옵션 사용
```bash
$ scp mint@host:/tmp/*.log /tmp/
$ scp -r mint@host:/tmp/results /tmp/
```
- 서버에서 서버에 파일 복사
```bash
$ scp mint@server:1:/data/file mint@server2:/backup/
```
- 앞은 복사 원선 서버명과 서버 경로, 뒤는 복사 대상 서버명과 서버 경로
- 자신의 PC로 통신을 중계하는 형식.
- 따라서, 시간이 지체될 수 있음

## top
- top : 시스템 부하 상태를 조사하는 명령어 (시스템 모니터의 CUI판)
  - 수초 간격으로 실시간으로 갱신하면서 표시해준다.
![top](/images/top.png)
- load average : cpu가 처리하는 걸 기다리는 작업 개수
  - CPU는 한 번에 하나밖에 할 수 없으니까 그동안 발생한 새로운 작업은 쌓아둔다.(load)
  - 또한, CPU는 쌓인 일을 순서대로 처리한다.
  - load average는 1분당 평균으로 몇 개의 일이 쌓이는지를 나타내는 값
  - 만약 작업량이 적으면 쌓인 자업량은 평균치로 0.1이나 0.2 정도로 무척 작다. 이건 CPU가 놀고 있다는 뜻
  - 반대로 하나의 작업에 시간이 너무 오래 걸리거나 작업 발생 속도가 처리 속도보다 빠르거나하면 작업이 점점 쌓이게 된다.
  - load average는 CPU 코어 수와 같이 볼 것
  - 첫 번째는 1분간 평균, 두 번째는 5분간, 세 번째는 15분간 평균
  - CPU 부하가 낮아도 load average가 높을 때도 자주 있음
    - 대표적인 예가 디스크 I/O
    - 메모리가 부족하면 디스크 I/O가 대량으로 발생한다!
    - CPU는 보통 작업 장소로 메인 메모리를 사용하지만 메모리 여유 공간이 부족하면 새로운 작업을 할 수 없게된다.
    - 이때 OS는 메모리에 있는 최근에 사용하지 않은 데이터를 정리해서 메모리 빈공간을 만들어낸다.
    - 정리된 데이터는 일단 하드 디스크로 옮기는데 이걸 스왑아웃이라고 한다. (반대는 스왑인, 양쪽을 포함해서 스왑)
- %CPU, TIME + : 어느 프로세스가 CPU를 많이 쓰고 있는지 확인
  - 과부하 원인을 찾을 땐 "CPU 사용률이 높다, CPU 시간도 길다" 이런 프로세스가 있는지 찾아보는게 빠르다.
- COMMAND : 프로세스를 실행했을 때 실행한 명령어가 표시된다.
  - C 를 누르면 상세 표시로 전환됨.
- %MEM : 프로세스가 소비하는 메모리량
- 정렬
  - Shift + M : 메모리 사용량 순서
  - Shift + T : CPU 시간 순서
  - Shift + P : CPU 사용량 순서

- **정리**
  - load average >= CPU 코어수가 되면 과부하 상태
  - CPU 사용률과 CPU 시간 양쪽이 큰 프로세스는 과부하 원인의 가능성이 높음
  - 과부하 원인인 프로세스는 Kill 명령어로 종료
  - load average가 높아도 CPU는 과부하 상태가 아닐 수도 있다.
  - 빈 메모리가 부족하면 -> 스왑(디스크 I/O)이 자주 발생 -> CPU 처리가 쌓임 -> load average가 높아져서 시스템 반응이 나빠짐
  - 스왑량이 급격히 증가한다면 주의가 필요

## 파이프라인
- 어떤 명령어 실행 결과 출력을 그대로 다른 명령어에 넘길 수 있다.
  - 받은 쪽 명령어는 열어야 할 파일 지정을 생략하는게 포인트
  - grep "/retro" access.log.1 | less

- 파일 내용을 다음 명령어에 출력하는 시작 그룹
  - cat : 파일 내용을 읽어서 그대로 출력 (비압축 텍스트 파일)
  - zcat : 압축 파일을 읽어서 내용을 풀어서 출력 (gzip 전용)
  - xcat : xz 전용
  - unzip : zip 전용
  - tail -f : 파일에 추가된 부분을 출력
- 중간에서 이전 명령어 출력을 가공하는 중간 그룹
  - grep : 해당하는 줄만 출력
  - sort : 재정렬
  - cut : 잘라냄
  - uniq : 중복 제거
  - seq, awk : 내용 변경
- 이전 명령어 출력을 가공하는 최종 그룹
  - less : 스크롤 할 수 있게 출력
  - tee : 파일을 저장
  - wc : 줄 수나 문자 수를 카운트
  - head : 첫 부분만 추출


## Links
- [만화로 배우는 리눅스 시스템 관리 1](http://book.naver.com/bookdb/book_detail.nhn?bid=10995037)
